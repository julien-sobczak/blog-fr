---
layout: post
title: 'Implementing Mockito from Scratch'
author: 'Julien Sobczak'
date: '2014-12-03T22:26:00.001+01:00'
categories: inspect
tags:
- java
- frameworks
- testing
---

<article class="post-inspect language-java">

  <h1>Implementing Mockito from Scratch</h1>
  <h2>Julien Sobczak</h2>

  <div class="post-content">

<blockquote>
  <p>
    "We decided during the main conference that we should use JUnit 4 and Mockito because we think they
      are the future of TDD and mocking in Java" - <em>Dan North, créateur du terme BDD</em>
  </p>
</blockquote>

<p class="intro">
  La syntaxe élégante de Mockito explique en grande partie son succès. Comment Mockito réussit-il à
  garder nos tests lisibles ? Que se cache-t-il derrière cette API ? C’est ce que nous allons découvrir.
</p>

<div class="licence">
  <p>
    <a href="https://github.com/mockito/mockito" target="_tab">Mockito</a> est publié sous
    <a href="http://opensource.org/licenses/MIT" target="_tab">licence MIT</a>. Le code présenté dans cet article a
    été simplifié pour des raisons évidentes et n’a pas pour vocation à être utilisé en dehors de ce contexte
    d’apprentissage. Cet article est basé sur la dernière version de Mockito (1.10.14) au moment de cet article.
  </p>
</div>


<h3>Un exemple</h3>

{% highlight java %}
public interface Registry
{
    Object lookup(String name);
}
{% endhighlight %}

<p>
  Cette interface très basique reprend le principe d’une
  <a href="http://martinfowler.com/eaaCatalog/registry.html" target="_tab">registry</a>.
  Pour limiter les appels, on décide de mettre en place un simple cache :
</p>

{% highlight java %}
public class RegistryCacheDecorator implements Registry
{

    private Registry decoratedRegistry;
    private Map<String, Object> cache = new HashMap<String, Object>();

    public RegistryCacheDecorator(Registry registry) {
        this.decoratedRegistry = registry;
    }

    public Object lookup(String name) {
        if (!cache.containsKey(name)) {
            cache.put(name, decoratedRegistry.lookup(name));
        }
        return cache.get(name);
    }

}
{% endhighlight %}

<p>
  Comment tester cette dernière classe et garantir que la registry n’est pas appelée deux fois pour un même nom ?
  L’utilisation d’un Test Double de type mock est nécessaire (Voir
  <a href="http://martinfowler.com/articles/mocksArentStubs.html" target="_tab">ce post de Martin Fowler pour les
    différences entre les différents types de Test Double</a>).
</p>

{% comment %} 11,19,26 {% endcomment %}
{% highlight java linenos %}
import static org.mockito.Mockito.*;

public class RegistryCacheDecoratorUnitTest
{

    private RegistryCacheDecorator decorator;
    private Registry registry;

    @Before
    public void before() {
        registry = mock(Registry.class);

        decorator = new RegistryCacheDecorator(registry);
    }

    @Test
    public void registryShouldOnlyBeCalledOnceForTheSameName() {
        // Given
        when(registry.lookup(anyString())).thenReturn(new BasicDataSource());

        // When
        decorator.lookup("datasource");
        decorator.lookup("datasource");

        // Then
        verify(registry, times(1)).lookup("datasource");
    }
}
{% endhighlight %}

<dl class="source-explanations">
  <dt>11</dt>
    <dd>On instancie un nouveau mock pour chaque test</dd>
  <dt>19</dt>
    <dd>On configure ce mock pour associer une instance de <code>DataSource</code> au nom <code>"dataSource"</code></dd>
  <dt>26</dt>
    <dd>On vérifie que la registry n’a été sollicitée qu’une seule fois avec ce nom.</dd>
</dl>

<p>
  Au lancement, le test passe au vert. <strong>L’objectif est maintenant de supprimer les imports Mockito et de
  réécrire le minimum de code pour faire fonctionner de nouveau ce test</strong>. On veillera à être le plus fidèle
  possible à l’implémentation de Mockito, dans le nommage des classes, dans les algorithmes, etc, même si quelques
  libertés seront prises pour ne pas trop allonger cet article.
</p>


<h3>C’est parti !</h3>

<p>
  Suite à la suppression des imports, notre code ne compile plus. On commence donc par définir la signature
  des méthodes manquantes :
</p>

{% highlight java %}
public class Mockito
{

    public static <T> T mock(Class<T> classToMock) {
        return null; // implémentée dans la partie "mock"
    }

    public static <T> OngoingStubbing<T> when(T methodCall) {
        return null; // implémentée dans la partie "when"
    }

    public static <T> T verify(T mock, Object aDefinir) {
        return mock; // implémentée dans la partie "verify"
    }

}
{% endhighlight %}

<p>
  Notre code ne compile toujours pas à cause de la référence à <code>OngoingStubbing</code>.
  Le code suivant devrait corriger le problème :
</p>

{% highlight java %}
public interface OngoingStubbing<T>
{
    OngoingStubbing<T> thenReturn(T value);
}
{% endhighlight %}

<p>Vous pouvez pour le moment ignorer cette interface, nous y reviendrons en temps voulu.</p>



<h3 id="mockito-from-scratch-mock"><code>mock</code> : La création d’un mock</h3>

<p>
  Créer un mock revient à créer un proxy, c’est-à-dire un objet qui se présente comme n’importe quel instance d’une
  classe mais dont le comportement est préprogrammé. Depuis Java 1.3, on peut utiliser les
  <a href="http://www.oracle.com/technetwork/java/generic-listener2-138155.html">Dynamic Proxies</a> pour créer
  dynamiquement une classe mais seulement à partir d’une interface. Cette restriction est problématique en pratique
  et c’est pour cette raison que la plupart des librairies comme Spring, Hibernate ou encore Mockito utilisent une
  librairie qui manipule directement le bytecode. La plus célèbre est
  <a href="https://github.com/cglib/cglib" target="_tab">cglib</a>. Ces librairies fonctionnent en créant une
  sous-classe de la classe donnée, ce qui s’avère bien plus souple (à condition que la classe ne soit pas <code>final</code>).
</p>

<p>
  Bien que reposant sur cglib, Mockito cherche à s’en abstraire à l’aide deux interfaces : <code>MockMaker</code>
  et <code>MockHandler</code>.
</p>

{% highlight java %}
public interface MockMaker {

    <T> T createMock(Class<T> classToMock, MockHandler handler);
}
{% endhighlight %}

<p>
  Une implémentation de <code>MockMaker</code> est responsable d’instancier un proxy de manière à ce que chaque
  appel de méthodes soit délégué à la classe <code>MockHandler</code> :
</p>

{% highlight java %}
public interface MockHandler
{
    Object handle(Invocation invocation) throws Throwable;
}
{% endhighlight %}

<p>
  La classe <code>Invocation</code> est quant à elle un simple Wrapper regroupant les propriétés liées à l’appel :
</p>

{% highlight java %}
public class Invocation {

    private final Object mock;
    private final Method method;
    private final Object[] arguments;
    private final MethodProxy methodProxy; // Specific cglib

    public Invocation(Object mock, Method method, Object[] args, MethodProxy methodProxy) {
        this.method = method;
        this.mock = mock;
        this.methodProxy = methodProxy;
        this.arguments = args;
    }

    public Object getMock() {
        return mock;
    }

    public Method getMethod() {
        return method;
    }

    public Object[] getArguments() {
        return arguments;
    }

}
{% endhighlight %}


<h4>cglib/ASM/Objenesis : le trio gagnant</h4>

<p>
  On touche du doigt la partie la plus bas niveau de Mockito. Le code reste néanmoins facilement compréhensible
  grâce à l’API de cglib qui repose sur celle encore plus bas niveau d’<a href="http://asm.ow2.org/" target="_tab">ASM</a>.
  Voici l’implémentation de <code>MockMaker</code> :
</p>

{% highlight java %}
import org.mockito.cglib.core.CodeGenerationException;
import org.mockito.cglib.proxy.Callback;
import org.mockito.cglib.proxy.Enhancer;
import org.mockito.cglib.proxy.Factory;
import org.mockito.cglib.proxy.MethodInterceptor;
import org.mockito.exceptions.base.MockitoException;
import org.objenesis.ObjenesisStd;

public class CglibMockMaker implements MockMaker {

    public <T> T createMock(Class<T> mockedType, MockHandler handler) {

        try {
            MethodInterceptor interceptor = new MethodInterceptorFilter(handler);

            Class<Factory> proxyClass = createProxyClass(mockedType);
            Object proxyInstance = createProxy(proxyClass, interceptor);
            return mockedType.cast(proxyInstance);
        } catch (ClassCastException cce) {
            throw new MockitoException(
                "Exception occurred while creating the mockito proxy", cce);
        }

    }

    public Class<Factory> createProxyClass(Class<?> mockedType) {
        Enhancer enhancer = new Enhancer();
        enhancer.setUseFactory(true);
        enhancer.setSuperclass(mockedType);
        enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class});

        try {
            return enhancer.createClass();
        } catch (CodeGenerationException e) {
            throw new MockitoException(
                "Mockito cannot mock this class: " + mockedType);
        }
    }

    private Object createProxy(Class<Factory> proxyClass, MethodInterceptor interceptor) {
        ObjenesisStd objenesis = new ObjenesisStd();
        Factory proxy = objenesis.newInstance(proxyClass);
        proxy.setCallbacks(new Callback[] {interceptor});
        return proxy;
    }

}
{% endhighlight %}

<p>
  Pas de panible. Le code est bien moins obscur qu’il n’y parait. Déroulons le code pas à pas.
</p>

<p>
  - On commence par créer une instance
  de <a href="http://cglib.sourceforge.net/apidocs/net/sf/cglib/proxy/Enhancer.html" target="_tab"><code>Enhancer</code></a>,
  la classe principale de cglib, chargée de créer de nouvelles classes dynamiquement.
</p>

{% highlight java %}
Enhancer enhancer = new Enhancer();
{% endhighlight %}

<p>- On décrit ensuite ce que l’on cherche à obtenir :</p>

{% highlight java %}
enhancer.setUseFactory(true);
enhancer.setSuperclass(mockedType);
enhancer.setCallbackTypes(new Class[]{MethodInterceptor.class});
{% endhighlight %}

<p>
  La ligne plus importante est la seconde où l’on spécifie la classe de notre mock. Pour comprendre la première
  ligne, il faut savoir que toutes les classes générées par cglib implémente par défaut l’interface
  <code>Factory</code>. Cette interface permet par exemple de changer de callback (patience nous y arrivons).
  La méthode <code>setUseFactory</code> permet de désactiver cela mais notre ligne ne fait que confirmer le défaut et
  est donc inutile. La dernière ligne indique le type de callback que l’on va utiliser. Plusieurs sont disponibles
  comme <code>FixedValue</code> qui retourne une valeur fixe à chaque appel de méthode. Le callback le plus souple
  est <code>MethodInterceptor</code> qui nous donne accès à toutes les informations concernant l’appel de méthode.
</p>

<p>- Reste alors à créer notre classe dynamique qui va nous servir de modèle pour instancier notre mock.</p>

{% highlight java %}
return enhancer.createClass();
{% endhighlight %}

<p>
  - Le moyen le plus simple pour créer une instance à partir d’un objet <code>Class</code>
  est la méthode <code>newInstance</code> :
</p>

{% highlight java %}
Class<T> cls = ...:
return cls.newInstance();
{% endhighlight %}

<p>
  Cette méthode s’appuie sur un constructeur par défaut. Cette restriction généralement acceptable peut poser
  quelques problèmes dans notre cas.
</p>

<p>Imaginons que la classe à mocker hérite d’une autre classe :</p>

{% highlight java %}
public class Parent {
  public Parent() {
    // will be executed by Child.class.newInstance()...
  }

}

public class Child extends Parent {

}
{% endhighlight %}

<p>Suivant le code du constructeur parent, le résultat peut être problématique.</p>

<div class="tip">
  <p class="title">Peut-on instancier un objet en Java sans utiliser de constructeur ?</p>
  <p>
    La réponse peut surprendre mais oui, grâce à la librairie <a href="http://objenesis.org/" target="_tab">Objenesis</a>.
    Là encore, il s’agit de manipulation de bytecode qui diffère selon la version de JVM, le vendeur et la version
    de la JVM du vendeur...
    (voir classe <a href="http://objenesis.org/apidocs/org/objenesis/strategy/StdInstantiatorStrategy.html" target="_tab">StdInstantiatorStrategy</a>
    pour les plus curieux).
  </p>
</div>

<p>Avec ces nouvelles connaissances, nous pouvons revenir à notre <code>MockHandler</code> :</p>

{% highlight java %}
MethodInterceptor interceptor = new MethodInterceptorFilter(handler);
ObjenesisStd objenesis = new ObjenesisStd();
Factory proxy = objenesis.newInstance(proxyClass);
proxy.setCallbacks(new Callback[] {interceptor});
return proxy;
{% endhighlight %}

<p>
  Objenesis crée une nouvelle instance de notre classe dynamique. Notre mock vient enfin de naître.
  On lui associe une instance de <code>MethodInterceptorFilter</code>, pour faire le lien entre cglib et notre
  <code>MockHandler</code>.
</p>

{% highlight java %}
import org.mockito.cglib.proxy.MethodInterceptor;

public static class MethodInterceptorFilter implements MethodInterceptor {

    private final MockHandler handler;

    public MethodInterceptorFilter(MockHandler handler) {
        this.handler = handler;
    }

    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy)
            throws Throwable {

        Invocation invocation = new Invocation(proxy, method, args, methodProxy);
        return handler.handle(invocation);
    }
}
{% endhighlight %}

<p>
  Avant de clore cette première partie, certains auront peut-être remarqué que Mockito repackage cglib (et ASM) :
</p>

{% highlight java %}
import org.mockito.cglib.proxy.Enhancer;
{% endhighlight %}


<div class="tip">
  <p class="title">Pourquoi repackager cglib ?</p>
  <p>
    Cglib n’offre pas une maintenance à l’image de sa popularité.
    A cela s’ajoute quelques versions instables qui ont atteri dans le Central Maven qui forcent donc des librairies
    comme
    <a href="https://github.com/Sdogruyol/mockito/tree/master/cglib-and-asm" target="_tab">Mockito</a> ou
    <a href="http://docs.spring.io/spring/docs/3.2.5.RELEASE/javadoc-api/org/springframework/cglib/package-summary.html" target="_tab">Spring</a>
    à repackager la librairie dans leur propre namespace pour garantir une version stable.
  </p>
</div>

<p>Cela soulève une autre question</p>

<div class="tip">
  <p class="title">cglib reste-il toujours la solution incontournable ?</p>
  <p>
    La tendance est clairement non. Les frameworks majeurs comme
    <a href="http://relation.to/16658.lace" target="_tab">Hibernate</a> ou <a href="https://jira.spring.io/browse/SPR-8190" target="_tab">Spring</a>
    ont ou envisage une migration vers une autre solution comme
    <a href="http://www.csg.ci.i.u-tokyo.ac.jp/~chiba/javassist/" target="_tab">javassist</a>.
  </p>
</div>

<p>
  Pour en savoir plus sur CGlib, <a href="http://java.dzone.com/articles/cglib-missing-manual" target="_tab">
  un excellent article est disponible</a> pour combler, soyons honnête, l’absence totale d’une documentation officielle.
</p>


<h3 id="mockito-from-scratch-when"><code>when</code> : programmation du mock</h3>

<p>
  Même si nous en avons fini avec le code bas niveau, la suite n’en est pas plus simple. L’API tellement bien
  pensée cache en réalité beaucoup d’ingéniosité pour la rendre opérationnelle.
</p>


<h4>Un premier aperçu....</h4>

{% highlight java %}
when(registry.lookup(anyString())).thenReturn(new Object());
{% endhighlight java %}

<p>Lors de l’exécution de cette ligne :</p>

<ul>
  <li>
    la méthode <code>anyString</code> est d’abord appelée. On mémorise l’utilisation de cet <code>ArgumentMatcher</code> (dans une variable globale).
  </li>
  <li>
    la méthode <code>registry#lookup(String)</code> est ensuite véritablement appelée (celle de notre mock). On mémorise l’invocation toujours de manière globale.
  </li>
  <li>
    la méthode <code>when</code> est appelée. On sait seulement alors que nous sommes en train de configurer notre mock.
  </li>
  <li>
    la méthode <code>thenReturn</code> est appelée. On exploite les données précédemment collectées, on sauvegarde la réponse pour être ensuite retournée quand le mock sera exercé pendant le test.
  </li>
</ul>

<p>
  Commençons par nous pencher sur cette fameuse variable globale, véritable boussole pour savoir à tout moment
  où nous nous trouvons. Cette variable est en réalité une instance de la classe <code>MockingProgress</code> :
</p>

{% highlight java %}
public class MockingProgress
{

    /** Variable globale */
    public static MockingProgress INSTANCE = new MockingProgress();

    private final List<Matcher> matcherStack = new ArrayList<Matcher>();
    private OngoingStubbing ongoingStubbing;


    /** Appelée à chaque ArgumentMatcher (anyString, eq, ...) */
    public void reportMatcher(Matcher matcher) {
        matcherStack.add(matcher);
    }

    /** Appelée lors de l'exécution du mock dans le when */
    public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {
        this.ongoingStubbing = ongoingStubbing;
    }

    /** Appelée par la méthode when pour confirmer le stubbing */
    public void stubbingStarted() {

    }

    /** Retourne les ArgumentMatchers mémorisés. */
    public List<Matcher> pullMatchers() {
        if (matcherStack.isEmpty()) {
            return Collections.emptyList();
        }

        List<Matcher> matchers = new ArrayList<Matcher>(matcherStack);
        matcherStack.clear();
        return matchers;
    }

    /**
     * Appelé par le when pour récupérer l'instance
     * à retourner pour chainer les méthodes.
     */
    public OngoingStubbing pullOngoingStubbing() {
        OngoingStubbing temp = ongoingStubbing;
        ongoingStubbing = null;
        return temp;
    }

}
{% endhighlight %}

<p>
  Cette classe sera modifiée lorsque nous attaquerons la dernière partie. Son code peut dérouter mais son principe
  est assez simple : dès qu’on en sait plus sur notre position dans le code, on le communique à cette classe qui
  permet également de retrouver au moment voulu les informations sauvegardées.
</p>

<p>
  Son fonctionnement deviendra plus clair à travers les prochaines classes.
</p>

<p>
  Revenons à quelque chose de plus simple pour le moment : les <code>ArgumentMatcher</code>, basés sur l’excellente
  librairie <a href="http://hamcrest.org/" target="_tab">Hamcrest</a> :
</p>

{% highlight java %}
import org.hamcrest.BaseMatcher;

public abstract class ArgumentMatcher<T> extends BaseMatcher<T> {

    public abstract boolean matches(Object argument);

}
{% endhighlight %}

<p>
  Mockito propose de nombreux matchers. Pour notre exemple, seuls deux seront nécessaires :
</p>

{% highlight java %}
public class Any<T> extends ArgumentMatcher<T> {

    @Override
    public boolean matches(Object actual) {
        return true; // n’importe quelle valeur autorisée
    }

    public void describeTo(Description description) {
        description.appendText("<any>");
    }
}

public class Equals<T> extends ArgumentMatcher<T> {

    private final Object wanted;

    public Equals(Object wanted) {
        this.wanted = wanted;
    }

    @Override
    public boolean matches(Object actual) {
        return wanted == actual;
    }

    public void describeTo(Description description) {
        description.appendText("<eq>");
    }
}
{% endhighlight %}

<p>
  Leur utilisation passe forcément par une méthode factory qui a double emploi : communiquer leur usage et
  retourner le type adapté pour que notre code compile (Note : instancier directement un matcher à la place du
  <code>anyString()</code> ne compilerait pas) :
</p>

{% highlight java %}
public class Matchers
{

    public static String anyString() {
        MockingProgress.INSTANCE.reportMatcher(new Any());
        return "";
    }

    public static <T> T eq(T value) {
        MockingProgress.INSTANCE.reportMatcher(new Equals(value));
        return value;
    }

}
{% endhighlight %}

<p>
  Avant de définitivement passer aux choses sérieuses, nous allons introduire la classe
  <code>InvocationMatcher</code> que l’on va retrouver à plusieurs reprises. Cette classe regroupe à la fois une
  <code>Invocation</code> (un appel de méthode) avec la liste des matchers utilisés. Même si nous disposons des
  arguments dans l’objet <code>Invocation</code>, les matchers eux ne sont pas présents comme en atteste la classe
  <code>Matchers</code> que nous venons de voir (<code>anyString</code> retourne par exemple une chaine vide).
  Voici le code de cette classe :
</p>

{% comment %} 16 {% endcomment %}
{% highlight java %}
public class InvocationMatcher {

    private final Invocation invocation;
    private final List<Matcher> matchers;

    public InvocationMatcher(Invocation invocation, List<Matcher> matchers) {
        this.invocation = invocation;
        if (matchers.isEmpty()) {
            this.matchers = argumentsToMatchers(invocation.getArguments());
        } else {
            this.matchers = matchers;
        }
    }

    public static List<Matcher> argumentsToMatchers(Object[] arguments) {
        List<Matcher> matchers = new ArrayList<Matcher>(arguments.length);
        for (Object arg : arguments) {
            matchers.add(new Equals(arg));
        }
        return matchers;
    }

    public Invocation getInvocation() {
        return this.invocation;
    }

    public List<Matcher> getMatchers() {
        return this.matchers;
    }

    public boolean matches(Invocation actual) {
        return invocation.getMock() == actual.getMock()
                && hasSameMethod(actual)
                && hasMatchingArguments(this, actual);
    }

    private boolean hasSameMethod(Invocation candidate) {
        Method m1 = this.getInvocation().getMethod();
        Method m2 = candidate.getMethod();
        return m1.equals(m2);
    }

    private boolean hasMatchingArguments(InvocationMatcher invocationMatcher,
                                         Invocation actual) {
        Object[] actualArgs = actual.getArguments();
        if (actualArgs.length != invocationMatcher.getMatchers().size()) {
            return false;
        }
        for (int i = 0; i < actualArgs.length; i++) {
            if (!invocationMatcher.getMatchers().get(i).matches(actualArgs[i])) {
                return false;
            }
        }
        return true;
    }

}
{% endhighlight %}

<dl class="source-explanations">
  <dt>16</dt>
  <dd>
    Lors d’un appel de méthode sur notre mock (aussi bien pour le <code>when</code> ou que pour le
    <code>verify</code>), Mockito autorise soit uniquement des littéraux/variables, ou uniquement des matchers. Par
    facilité d’implémentation, Mockito veille à ne travailler qu’avec des matchers. C’est le rôle de la méthode
    <code>argumentsToMatchers</code>.
  </dd>
</dl>

<p>
  Il nous reste encore plusieurs classes à aborder. Continuons avec la classe <code>InvocationContainer</code>.
  Contrairement à <code>MockingProgress</code> qui est partagée entre tous les mocks et tous les tests, chaque mock
  dispose de sa propre instance de <code>InvocationContainer</code>. Cette classe conserve l’ensemble des
  invocations "stubbées", c’est-à-dire les invocations à l’aide du <code>when</code> permettant de programmer notre
  mock mais aussi l’ensemble des invocations réelles durant l’exécution du test, celles qui vont servir à valider
  nos affirmations (<code>verify</code>).
</p>

{% comment %} 4,5,6,8 {% endcomment %}
{% highlight java %}
public class InvocationContainer
{

    private final Map<InvocationMatcher, Answer> stubbed = new HashMap<InvocationMatcher, Answer>();
    private InvocationMatcher invocationForStubbing;
    private LinkedList<Invocation> registeredInvocations = new LinkedList<Invocation>();

    public void setInvocationForPotentialStubbing(InvocationMatcher invocationMatcher) {
        registeredInvocations.add(invocationMatcher.getInvocation());
        invocationForStubbing = invocationMatcher;
    }

    public void addAnswer(Answer answer) {
        registeredInvocations.removeLast();
        stubbed.put(invocationForStubbing, answer);
        invocationForStubbing = null;
    }

    public List<Invocation> getInvocations() {
        return registeredInvocations;
    }

    public Answer findAnswerFor(Invocation invocation) {
        for (Entry<InvocationMatcher, Answer> eachEntry : stubbed.entrySet()) {
            InvocationMatcher eachInvocationMatcher = eachEntry.getKey();
            Answer eachAnswer = eachEntry.getValue();
            if (eachInvocationMatcher.matches(invocation)) {
                return eachAnswer;
            }
        }

        return null;
    }

}
{% endhighlight %}

<dl class="source-explanations">
  <dt>4</dt>
  <dd>
    <code>stubbed</code> contient tous les appels stubbés enregistrés à l'aide du <code>when</code>.
  </dd>
  <dt>5</dt>
  <dd>
    <code>invocationForStubbing</code> contient l'appel en cours. On ne sait pas encore si il s'agit d'un appel
    stubbé (<code>when</code>), d'un appel normal, ou d'un appel dans le cadre du <code>verify</code>.
  </dd>
  <dt>6</dt>
  <dd>
    <code>registeredInvocations</code> contient tous les appels réels aux mocks, c'est-à-dire les appels qui
    n'interviennent pas lors d'un <code>when</code> ou <code>verify</code>.
  </dd>
  <dt>8</dt>
  <dd>
    Cette méthode est appelée à chaque appel d’une méthode sur un mock. Il peut s’agir d’un appel durant un <code>when</code>
    ou d’un appel réel. Dans le premier cas, la méthode <code>addAnwser</code> sera ensuite appelée (par le <code>thenReturn</code>
    par exemple) pour nous permettre d’ajouter cette invocation dans la liste des invocations "stubbées". Pour le
    second cas, nous n’avons pas d’équivalent. Il s’agit là de notre seule chance de prendre note de l’appel. On
    ajoute donc l’invocation à la liste des invocations réelles et on la supprimera si jamais la méthode <code>addAnswer</code>
    est appelée.
  </dd>
</dl>

<p>
  Les réponses sont représentées par l’interface <code>Answer</code>. Elles peuvent correspondre à une valeur de
  retour (<code>thenReturn</code>), à une exception à lancer (<code>thenThrow</code>), etc.
</p>

{% highlight java %}
public interface Answer<T> {
    T answer(Invocation invocation) throws Throwable;
}

public class Returns implements Answer<Object> {

    private final Object value;

    public Returns(Object value) {
        this.value = value;
    }

    public Object answer(Invocation invocation) throws Throwable {
        return value;
    }

}

public class ThrowsException implements Answer<Object> {

    private final Throwable throwable;

    public ThrowsException(Throwable throwable) {
        this.throwable = throwable;
    }

    public Object answer(Invocation invocation) throws Throwable {
        throw throwable;
    }

}
{% endhighlight %}

<p>
  L’enregistrement des réponses se fait par une des premières classes introduites dans cet article (çà remonte…).
  Il s’agit de la classe <code>OngoingStubbing</code> retournée par la méthode <code>when</code>. Voici son contenu
  modifié :
</p>

{% highlight java %}
public static class OngoingStubbing<T>
{

    private final InvocationContainer invocationContainer;

    public OngoingStubbing(InvocationContainer invocationContainer) {
        this.invocationContainer = invocationContainer;
    }

    public OngoingStubbing<T> thenReturn(T value) {
        return thenAnswer(new Returns(value));
    }

    public OngoingStubbing<T> thenThrow(Throwable throwable) {
        return thenAnswer(new ThrowsException(throwable));
    }

    public OngoingStubbing<T> thenAnswer(Answer<?> answer) {
        invocationContainer.addAnswer(answer);
        return this;
    }
}
{% endhighlight %}

<p>
  Cette deuxième partie touche à sa fin. Reste à assembler toutes les briques ensemble.
  C’est le rôle de la classe déjà introduite <code>MockHandler</code>, appelée à chaque appel de méthode sur notre mock :
</p>

{% comment %} 8,13,16,26 {% endcomment %}
{% highlight java %}
public class MockHandlerImpl<T> implements MockHandler
{

    private MockingProgress mockingProgress = MockingProgress.INSTANCE;
    private InvocationContainer invocationContainer;

    public MockHandlerImpl() {
        this.invocationContainer = new InvocationContainer();
    }

    public Object handle(Invocation invocation) throws Throwable {

        List<Matcher> lastMatchers = mockingProgress.pullMatchers();
        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);

        invocationContainer.setInvocationForPotentialStubbing(invocationWithMatchers);
        OngoingStubbing<T> ongoingStubbing = new OngoingStubbing<T>(invocationContainer);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        // look for existing answer for this invocation
        Answer answer = invocationContainer.findAnswerFor(invocation);

        if (answer == null) { // when?
            return null;
        } else { // called by the test
            return answer.answer(invocation);
        }
    }

}
{% endhighlight %}

<dl class="source-explanations">
  <dt>8</dt>
  <dd>
    Chaque <code>MockHandler</code> est associé à une instance de mock. C’est donc l’endroit idéal pour créer
    notre <code>InvocationContainer</code>.
  </dd>
  <dt>13</dt>
  <dd>On dépile les matchers pour créer notre <code>InvocationMatcher</code>.</dd>
  <dt>16</dt>
  <dd>On enregistre un début possible de stubbing (sera confirmé plus tard).</dd>
  <dt>26</dt>
  <dd>Si une réponse a déjà été enregistrée, on la retourne.</dd>
</dl>

<p>
  N’oublions pas également de revoir notre implémentation initiale du <code>when</code> :
</p>

{% highlight java %}
public class Mockito
{
    // ...

    public static <T> OngoingStubbing<T> when(T methodCall) {
        mockingProgress.stubbingStarted();
        return mockingProgress.pullOngoingStubbing();
    }

}
{% endhighlight %}



<h3 id="mockito-from-scratch-verify"><code>verify</code></h3>

<p>
  Comparée à la deuxième, cette troisième partie s’annonce bien moins périlleuse.
</p>


<h4>Un premier aperçu...</h4>

{% highlight java %}
verify(registry, times(1)).lookup(anyString());
{% endhighlight %}

<p>Lors de l’exécution de cette ligne :</p>

<ul>
  <li>
    la méthode <code>times</code> est appelée. Cette factory se contente de créer une instance de <code>VerificationMode</code>.
  </li>
  <li>
    la méthode <code>verify</code> est appelée. On mémorise le résultat attendu passé en paramètre
    (<code>times(1)</code>) toujours dans notre objet globale <code>MockingProgress</code>.
  </li>
  <li>
    la méthode <code>anyString()</code> est appelée. Comme toujours, on mémorise les matchers pour plus tard.
  </li>
  <li>
    la méthode <code>registry#lookup(String)</code> est à nouveau appelée. On passe donc dans l’incontournable
    <code>MockHandler</code> et c’est véritablement là que la vérification se fait. On dépile les matchers et on
    recherche les invocations réelles satisfaisant cette invocation "stubbée".
  </li>
</ul>

<p>Commençons par introduire les <code>VerificationMode</code> :</p>

{% highlight java %}
public interface VerificationMode
{
    void verify(VerificationData data);
}
{% endhighlight %}

<p>
  Comme pour les matchers, de nombreuses implémentations sont disponibles. Seule <code>times</code> nous intéresse ici :
</p>

{% highlight java %}
public class Times implements VerificationMode
{

    final int wantedCount;

    public Times(int wantedNumberOfInvocations) {
        this.wantedCount = wantedNumberOfInvocations;
    }

    public void verify(VerificationData data) {
        int actualCount = 0;
        for (Invocation eachInvocation : data.getAllInvocations()) {
            if (data.getWanted().matches(eachInvocation)) {
                actualCount++;
            }
        }
        if (actualCount != wantedCount) {
            throw new MockitoAssertionError(
                "Actual: " + actualCount + ", expected: " + wantedCount);
        }
    }

}
{% endhighlight %}

<p>
  La vérification est aisée grâce à l’objet <code>VerificationData</code> qui regroupe toutes les invocations
  réelles et l’invocation "stubbée" (celle du <code>verify</code>). Il suffit de rechercher toutes celles
  correspondantes, et de comparer avec le nombre attendu.
</p>

{% highlight java %}
public class VerificationData
{

    private final InvocationMatcher wanted;
    private final InvocationContainer invocations;

    public VerificationData(InvocationContainer invocations, InvocationMatcher wanted) {
        this.invocations = invocations;
        this.wanted = wanted;
    }

    public List<Invocation> getAllInvocations() {
        return invocations.getInvocations();
    }

    public InvocationMatcher getWanted() {
        return wanted;
    }
}
{% endhighlight %}

<p>Il nous faut également revoir notre implémentation initiale de la méthode <code>verify</code> :</p>

{% highlight java %}
public class Mockito
{

    // …

    public static <T> T verify(T mock, VerificationMode mode) {
        mockingProgress.verificationStarted(mode);
        return mock;
    }

}
{% endhighlight %}

    <p>Ainsi que du <code>MockingProgress</code> :</p>

{% highlight java %}
public class MockingProgress
{

    // …

    private VerificationMode verificationMode;

    public void verificationStarted(VerificationMode verify) {
        ongoingStubbing = null;
        verificationMode = verify;
    }

    public VerificationMode pullVerificationMode() {
        VerificationMode temp = verificationMode;
        verificationMode = null;
        return temp;
    }
}
{% endhighlight %}

<p>Sans oublier la classe centrale <code>MockHandler</code> qui se complexifie à nouveau :</p>

{% comment %} 13,18-22,38-40 {% endcomment %}
{% highlight java %}
public static class MockHandlerImpl<T> implements MockHandler
{

    private MockingProgress mockingProgress = MockingProgress.INSTANCE;
    private InvocationContainer invocationContainer;

    public MockHandlerImpl() {
        this.invocationContainer = new InvocationContainer();
    }

    public Object handle(Invocation invocation) throws Throwable {

        VerificationMode verificationMode = mockingProgress.pullVerificationMode();

        List<Matcher> lastMatchers = mockingProgress.pullMatchers();
        InvocationMatcher invocationWithMatchers = new InvocationMatcher(invocation, lastMatchers);

        if (verificationMode != null) { // verify?
            VerificationData data = createVerificationData(invocationContainer, invocationWithMatchers);
            verificationMode.verify(data);
            return null;
        }

        invocationContainer.setInvocationForPotentialStubbing(invocationWithMatchers);
        OngoingStubbing<T> ongoingStubbing = new OngoingStubbing<T>(invocationContainer);
        mockingProgress.reportOngoingStubbing(ongoingStubbing);

        // look for existing answer for this invocation
        Answer answer = invocationContainer.findAnswerFor(invocation);

        if (answer == null) { // when?
            return null;
        } else { // called by the test
            return answer.answer(invocation);
        }
    }

    private VerificationData createVerificationData(InvocationContainer invocationContainer, InvocationMatcher invocationMatcher) {
        return new VerificationData(invocationContainer, invocationMatcher);
    }
}
{% endhighlight %}


<div class="congratulations">
  <p class="title">Terminé !</p>
  <p>
    Bravo, vous venez de réaliser <strong>une version de Mockito opérationnelle en moins de 500 lignes</strong>.
    Le source complet est disponible <a href="https://github.com/julien-sobczak/mockito-from-scratch">ici</a>.
  </p>
</div>


<h3>Et c’est pas fini !</h3>

<h4>Bonus : le multithreading</h4>

<p>
  La plupart des classes sont associées à une instance de mock. Chaque mock dispose de son propre
  <code>MockHandler</code>. La seule classe à synchroniser est la classe <code>MockingProgress</code>, servant de
  variable statique pour supporter l’API mockito. Avec l’aide de la classe Java <code>ThreadLocal</code>, sa
  synchronisation est presque transparente :
</p>

{% highlight java %}
public class ThreadSafeMockingProgress {

    private static final ThreadLocal<MockingProgress> mockingProgress =
        new ThreadLocal<MockingProgress>();

    static MockingProgress threadSafely() {
        if (mockingProgress.get() == null) {
            mockingProgress.set(new MockingProgress());
        }
        return mockingProgress.get();
    }

    // ...

    public void verificationStarted(VerificationMode verify) {
        threadSafely().verificationStarted(verify);
    }

    public VerificationMode pullVerificationMode() {
        return threadSafely().pullVerificationMode();
    }

}
{% endhighlight %}

<p>
  Chaque méthode commence systématiquement par récupérer l’instance associée au thread courant à l’aide de la
  méthode <code>get</code> de <code>ThreadLocal</code>. Il ne nous reste plus qu’à remplacer dans les classes qui en
  dépendent :
</p>

{% highlight java %}
MockingProgress mockingProgress = MockingProgress.INSTANCE;
{% endhighlight %}

<p>par :</p>

{% highlight java %}
MockingProgress mockingProgress = new ThreadSafeMockingProgress();
{% endhighlight java %}

<p>Et le tour est joué !</p>

<h4>Bonus : La gestion des erreurs</h4>

<p>
  La gestion des erreurs passe bien évidemment par des exceptions mais ces exceptions ne sont pas lancées
  directement à chaque erreur détectée. Au contraire, Mockito délègue cette responsabilité à une classe <code>Reporter</code>
  qui regroupe l’ensemble des erreurs possibles. Pour chaque erreur, une méthode spécifique est proposée. Voici un
  extrait de cette classe :
</p>

{% highlight java %}
package org.mockito.exceptions;

public class Reporter {

    public void incorrectUseOfApi() {
        throw new MockitoException(join(
                "Incorrect use of API detected here:",
                new LocationImpl(),
                "",
                "You probably stored a reference to OngoingStubbing ...",
                "Examples of correct usage:",
                "    when(mock.isOk()).thenReturn(true).thenThrow(exception);",
                "    when(mock.isOk()).thenReturn(true, false).thenThrow(exception);",
                ""
        ));
    }

    public void notAMockPassedToWhenMethod() {
        throw new NotAMockException(join(
                "Argument passed to when() is not a mock!",
                "Example of correct stubbing:",
                "    doThrow(new RuntimeException()).when(mock).someMethod();"
        ));
    }

    public void invalidUseOfMatchers(int expectedMatchersCount,
                                     List<LocalizedMatcher> recordedMatchers) {
        throw new InvalidUseOfMatchersException(join(
                "Invalid use of argument matchers!",
                expectedMatchersCount + " matchers expected, " + recordedMatchers.size() +
                    " recorded:" + locationsOf(recordedMatchers),
                "",
                "This exception may occur if matchers are combined with raw values:",
                "    //incorrect:",
                "    someMethod(anyObject(), \"raw String\");",
                "When using matchers, all arguments have to be provided by matchers.",
                "For example:",
                "    //correct:",
                "    someMethod(anyObject(), eq(\"String by matcher\"));",
                "",
                "For more info see javadoc for Matchers class.",
                ""
        ));
    }

    // …
}
{% endhighlight %}

<p>
  L’avantage de cette approche est de rendre facile la personnalisation des messages en un endroit unique,
  garantissant une cohérence globale sur les messages affichés à l'utilisateur. Pour l’utiliser :
</p>

{% highlight java %}
new Reporter().invalidUseOfMatchers(...);
{% endhighlight %}

<div class="remember">
  <p class="title">A retenir</p>
  <ul>
    <li>Une <strong>API simple d’utilisation n’est pas synonyme d’une implémentation facile</strong>.</li>
    <li>Il est <strong>possible d’instancier une classe en Java sans passer par un constructeur</strong> à l’aide de librairies comme Objenesis</li>
    <li>Pour créer un <strong>proxy d’une classe sans interface</strong>, il faut recourir à de la <strong>manipulation de bytecode</strong> à l’aide de librairies comme Cglib ou Javassist.</li>
    <li>Cglib reste incontournable dans les frameworks existants mais sa pérennité n’est plus assurée. Nombreux sont les projets migrant vers Javassist.</li>
    <li>L’utilisation du <code>ThreadLocal</code> permet de partager un contexte global pour chaque thread de l’application.</li>
  </ul>
</div>

<div class="experiment">
  <p class="title">A vous de forker</p>
  <p>
    Notre découverte de Mockito nous aura entraîné dans les recoins les plus reculés de la librairie.
    Il reste pourtant tant de choses à découvrir. Voici quelques idées de fonctionnalités non présentées :
  </p>
  <ul>
    <li>
      Mockito propose la vérification "inOrder" qui garantit que deux mocks sont sollicités dans un ordre bien
      précis. Sachant que InvocationContainer est associé à un seul mock, comment cette fonctionnalité est-elle
      implémentée ? <em>Indice</em>:
      La classe <a href="https://github.com/mockito/mockito/blob/master/src/org/mockito/internal/invocation/InvocationImpl.java" target="_tab"><code>InvocationImpl</code></a>
      contient un attribut <code>sequenceNumber</code>.
    </li>
    <li>
      Mockito propose une méthoe <code>verifyZeroInteractions</code>, qui comme son nom l’indique,
      garantit qu’aucune interaction autre que celle préprogrammée n’a eu lieu sur un mock. Comment cela fonctionne-t-il ?
      <em>Indice</em> : La classe <a href="https://github.com/mockito/mockito/blob/master/src/org/mockito/internal/invocation/InvocationImpl.java" target="_tab"><code>InvocationImpl</code></a>
      contient un attribut <code>verified</code>.
    </li>
    <li>
      Mockito propose pour un même appel <code>when</code> d’enchainer plusieurs appels <code>thenReturn</code>,
      <code>thenThrow</code>, ... qui vont correspondre au résultat de la première, puis de la seconde, etc
      exécution de la méthode. <em>Indice</em> : comparer <code>OngoingStubbingImpl</code> et <code>ConsecutiveStubbing</code>.
    </li>
  </ul>
</div>


  </div>
  <div class="clearfix"></div>
</article>